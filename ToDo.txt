! В модуле In неправильно работает ввод действительных (REAL, LONGREAL) чисел,
  проявляется в методе Ньютона
! MinGW v3.1 некорректно работает с типом long double

* Проверить преобразование чисел в лекс. анализаторе, возможно, имеет смысл
  использовать ф-цию strtod

+ Добавить в Import #define WIN32_LEAN_AND_MEAN перед #include <windows.h> для
  ускорения компиляции (WinConsole)

? В CExprList::WriteCPP_proc_OneParam проверить работу с многомерными массивами

? Использовать при выбросе исключений макросы __FILE__ и __LINE__

- В обработчике по умолчанию воспринимать переменные как указатели на обобщения

+ В некоторых случаях можно облегчить проверку путем устранения создания объектов,
  например, отсутствие DeclSeq в процедуре можно проверить без создания
  CDeclSeq (по наличию BEGIN или END), тогда можно не создавать CDeclSeq

- Не выполняется проверка соответствия сигнатур обработчиков обобщающим процедурам

- Проверить, а нужен ли вообще в каталоге Import модуль SYSTEM ?

? При экстреннем выходе из программы (отсутствие обработчика по умолчанию, отсутствие
  ELSE в WITH и т.д.) необходимо выводить соотв. сообщение об ошибке (?)

- Проверить передачу ук. на специализированное обобщение в виде VAR-параметра при
  вызове процедуры (обычной)

- Разобраться с присвоением через ук. на специализированное обобщение содержимого
  записи соответствующего типа (типа специализации)

- pf := pfc <- допустимо в случае указателей, но недопустимо в случае
  параметров-переменных

- CDeclSeq::parent_element объявлен как public для обеспечения доступа в
  CCommonType::CheckSpecType, возможно, CheckSpecType следует перенести в
  CBaseName ?

- Ошибка - допустим вызов обобщенной процедуры без указания обобщенных параметров
  изнутри тела обработчика (но только оттуда)

- Скорее всего, ст. процедура COPY глючит с импортированными переменными - открытыми
  массивами (не генерируется имя модуля для переменной, содержащей размер)

- Неверная генерация кода в случае параметра процедуры типа POINTER TO ...
  (происходит генерация объявления типа O2M_UNNM_...)

* В случае указателей и записей с полями-указателями не работает проверка
  экспорта read-only, в DFN не генерируется признак read-only

* В O2M допускается использовать ук. на запись вместо параметра-переменной,
  исправить генерацию кода (добавляется лишний "&") (работает в BlackBox, не
  работает в Job)

- При передаче ук. на открытый массив в качестве фактического параметра в процедуру
  при вызове процедуры не учитывается, что вызов может находиться в теле модуля,
  поэтому длину массива надо определять не как переменную

* При объявлении специализированной обобщенной переменной внутри записи
  не генерируется код вызова специализтрующего конструктора, данный вызов конструктора
  необходимо генерировать в конструкторе записи

* Заменить O2M_SYS_ID на O2M_ID, O2M_SYS_ на O2M_MODULE_ (возможны конфликты :_( ),
  перед названиями пространств имен вставлять O2M_NS_ (?)

* Разобраться с использованием алиасов модулей в признаках обобщений с флагом "TYPE"

* В случае записи импортированного типа, имеющей поле-указатель на эту же запись
  непонятно, как искать описание типа указателя - поле привязано (parent_element) к
  переменной-записи, в то время как описание типа надо искать в Dfn модуле (?!)
* Проверить proc(OpenArray) - для импортированного типа массива при генерации кода
  не подставляет название (алиас?) модуля
* Проверить генерацию кода экспортируемой записи неименованного типа (в т.ч. с названием,
  совпадающим с названием импортированного модуля с использованием псевдонима)

* Проверить объявление вида TRec* = RECORD recu* : POINTER TO TRec END; (допустимо),
  аналогично для массивов
* Проверить работу с массивом указателей на запись (в FinalTests),
  в тестах проверить работу сложных обозначений, использование в параметрах вызова
  процедуры конструкции "pointer^",
  генерацию DFN в случае PROCEDURE qwe () : POINTER TO ARRAY ...
* Проверить Composite - RECORD name = POINTER TO ARRAY 10 OF CHAR END; (в FinalTests)

* Проблема - при совпадении названия записи с именем импортированного с использованием
  псевдонима модуля при обращении к полям записи nmake выдает ambigous symbol
  (способ устранения - вместо неименованного пространства имен для глобальных
  переменных использовать искуственное имя :( )
* Проверить, что там с возвратом указателя на наследника записи в процедуре
  (исправлять пока не требуется)
* В CDeclSeq::WriteCPP_var - генерируется код только переменных, параметрические
  объекты могут быть отсечены (в CDeclSeq::WriteCPP_proc ид-ы указаны в явном виде) -
  проверить
* Проверить совпадение имени объявляемой переменной с именем импортированного модуля
  (собственным или алиасом)
* Проверить объявление типа ук. на еще не объявленный тип массив эл-тов данного типа
  (вообще-то данное объявление бессмысленно, но код надо генерировать корректно)
* Запретить вызов процедуры, связанной с типом, без указания записи или ук. на запись
  (требование языка)
* Доделать сравнение процедур (CompareDeclarations), проверку совпадения параметров
  (Matching Formal Pars) процедуры связанной с типом и переопределяемой ею процедуры
* Приемник-ук. означает использование процедуры только через ук., в то время как
  приемник-запись работает во всех случаях
* Ввести проверку типа эл-тов массива и типа, на кот. указывает указатель:
  обработать ст. процедуру NEW
* Вместо s_e_AssignConst использовать "not l-value" (?)
* Избавиться от CArrayType в списке parent_element, нужно ввести специальный класс
  CArrayDimension (наследник от CBaseName) для описания вхождения одного
  измерения массива. Разобраться также с CRecordType, CRecordVar, CPointerVar
  (имеют FindName).
  В перспективе - создать абстрактный базовый класс CBaseParent
  (наследник от CBaseName), от которого наследовать классы, которые могут
  входить в список parent_element (CModule, CDfnModule, CProcedure,
  CWithLoopLink, CArrayDimension). В этот класс нужно включить методы работы
  с таблицей имен (FindName, AddName, FindQualName - вместо GetGlobalName,
  FindImportedName) и сделать их абстрактными, соответственно, данные методы
  убираются из CBaseName. Помнить, что module_name может также быть именем переменной
  типа запись или ук. на запись
  Таким образом, вызов GetGlobalName заменяется на parent_element->FindQualName
* '^' в Designator не должен игнорироваться в случае вызова процедуры, связанной с
  типом - в данном случае он означает вызов переопределенной процедуры
* Тип результата процедуры не может быть ни записью, ни массивом
* В Oberon_System_3 есть подробное описание модулей In и Out
* после загрузки ExprList проверять его соответствие сигнатуре процедуры
* Совместимость по присваиванию (Common.cpp), RETURN
* Разобраться с вложенными процедурами (реализовать объявление локальных для
  процедуры переменных в namespace перед процедурой)
* Проверить вывод "const" при генерации кода констант
* При обобщении импортированных типов при генерации кода не происходит замена
  синонима имени модуля, экспортирующего тип признака, при экспорте указателя
  не происходит замена синонима типа на его имя при записи в заголовочный
  .h-файл (протестировать)
! В формальных параметрах процедуры не допускается создание неименованного типа
  RECORD (в Обероне-2 это допускается)
! Операции DIV и MOD реализованы как в BlackBox (допускается использование отрицательного
  делителя)



||===================
|| JOB компилятор:
|| Ошибка: ODD не работает с типом LONGINT
|| Неполная реализация: "не реализован процедурный тип"
|| Сомнительный момент: LEN не работает со строковыми константами
|| Возможная ошибка: в модуле экспортируется переменная не экспортируемого типа RECORD,
||   при этом генерируется .dfn, но если в другом модуле попытаться использовать данную
||   переменную, появится ошибка в этом .dfn
|| Ошибка: допускается экспорт "только для чтения" для объектов кроме переменных и
||   полей записи
|| Ошибка: в приемнике допускается указывать параметр-значение для ук. на запись
|| Ошибка: допускается создание одноименных методов для записи и ук. на эту же запись
|| Ошибка: в опережающем описании допускается описывать параметры, при этом в процедуре
||   их можно не описывать (сделано как в паскале)
|| Ошибка: некорректная обработка объявления в записи ук. на саму эту запись вида
||   TRec = RECORD recu : POINTER TO TRec END;
|| Ошибка: функция COPY не работает, если источник длиннее получателя (в этом случае
||   в получателе строка должна обрезаться до (длина-1) и добавляться 0X)
||===================
|| Oberon System 3
|| Ошибка: допускается объявление типа вида <Имя>=<Тип> в точке, где <Тип> еще не
||   известен (в Black Box это является допустимым)
||===================
