Механизм сборки мусора
----------------------

Пример возможной реализации в файле "Counter.cpp".
Реализация механизма сборки мусора должна обеспечивать:


1. Счетчик ссылок - глобальная таблица, содержащая пары (void*, int) - значение
   указателя + количество ссылок. Доступны глобальная процедура

void O2M_CLEANER_INC(void*);

   увеличивающая счетчик ссылок на 1 для указанного указателя, и глобальная функция

bool O2M_CLEANER_DEC(void*);

   уменьшающая счетчик ссылок на 1 и возвращающая true, если счетчик <= 0.
   В случае нулевого указателя (NIL) никаких действий не выполняется


2. Для каждого типа указатель создается процедура очистки вида:

    bool O2M_CLEAN_<имя>(void*);

   или

    bool O2M_CLEAN_<имя открытого массива>(void*, int size0);	//{, ..., size<N-1>}

   где <имя> - имя типа в случае именованного типа, имя переменной неименованного
   типа (например, для "VAR pA : POINTER TO RECORD END" получаем "O2M_CLEAN_pA").
   В случае нескольких переменных неименованного типа процедура очистки создается для
   каждой переменной, т.к. запись
     VAR pA, pB : POINTER TO RECORD END;
   при генерации кода интерпретируется как
     VAR pA : POINTER TO RECORD END;
     VAR pB : POINTER TO RECORD END;
   Процедура очистки возвращает признак удаления переданного указателя. Данная процедура
   вызывается после операции с указателем, уменьшающей счетчик ссылок:

// VAR pA, pB : POINTER TO TRec;
// pA := pB;
{
	void* O2M_TMP_POINTER = pA;
	pA = pB;
	O2M_CLEANER_INC(pB);
	O2M_CLEAN_TRec(O2M_TMP_POINTER);
}

   Данная процедура обеспечивает:
   1) Уменьшение счетчика ссылок на 1 для переданного указателя
   2) Проверку достижения счетчиком 0 (через вызов O2M_CLEANER_DEC), если счетчик
      достиг 0, выполняется уничтожение объекта (см. ниже) с приведением типа void
      к требуемому типу, обнуление указателя

   Примечание: в случае массивов указателей процедура обеспечивает перебор эл-тов
     массива с вызовом процедуры очистки для каждого эл-та, в случае записей - вызов
     процедуры очистки для каждого члена - указателя. Размер(ы) массива при вызове
     процедуры определяются по правилам определения размеров открытых массивов


3. Код, встраиваемый в тело программы при вызове NEW:

// VAR pA : POINTER TO TRec;
	TRec* pA;
// NEW(pA);
	O2M_CLEAN_TRec(pA);
	pA = new(TRec);
	O2M_CLEANER_INC(pA);


4. Код, встраиваемый в процедуру (функцию), использующую формальные
   параметры - указатели (не VAR), выход из области видимости:

//PROCEDURE TestProc(p : POINTER TO TRec);
void TestProc(TRec* p) {
	//для не VAR параметров подразумевается неявное присваивание значения формального
	//параметра => требуется увеличение счетчика ссылок
	O2M_CLEANER_INC(p);

	//VAR pC : POINTER TO TRec;
	TRec* pC;

	//в теле процедуры обычная вставка обращений к сборщику мусора:
	//NEW(pC);
	O2M_CLEAN_TRec(pC);
	pC = new(TRec);
	O2M_CLEANER_INC(pC);

	//при выходе из области видимости необходимо очищать локальные переменные
	O2M_CLEAN_TRec(pC);

	//при выходе из области видимости необходимо уменьшать счетчик ссылок
	//(только для не VAR параметров)
	O2M_CLEAN_TRec(p);
}

   Также в конце блока инициализации модуля необходимо очищать неэкспортированные
   глобальные переменные-указатели. Экспортируемые глобальные указатели не очищаются,
   т.к. они могут использоваться в других модулях.


5.1. Пример процедуры очистки для массива:

// TYPE TArr = ARRAY 10 OF CHAR;
// (* переменная - ук. на именованный тип *)
// VAR pA : POINTER TO TArr;
bool O2M_CLEAN_pA(void* p)
{
	if (O2M_CLEANER_DEC(p)) {
		delete static_cast<TArr*>(p);
		p = 0;
		return true;
	} else
		return false;
}

// (* переменная - ук. на неименованный массив указателей на именованный тип *)
// (* используется сгенерированное компилятором имя O2M_UNNM_<имя переменной> *)
// VAR pArr : POINTER TO ARRAY 10 OF POINTER TO TRec;
bool O2M_CLEAN_pArr(void* p)
{
	if (O2M_CLEANER_DEC(p)) {
		for (int i = 0; i < 10; i++) O2M_CLEAN_TRec(static_cast<O2M_UNNM_pArr*>(p)[i]);
		delete[] static_cast<O2M_UNNM_pArr*>(p);
		p = 0;
		return true;
	} else
		return false;
}
