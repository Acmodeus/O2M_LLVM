Oberon2M v1.4.046
- Исправлен рекурсивный вызов процедур
- В файле настройки директива MAIN определяет главный файл проекта (аналог
  ключа -m)
- Исправлена генерация кода вызова процедуры-функции, не имеющей параметров
- Убраны лишние промежуточные using (теперь только в случае переименования
  модуля при импорте)
- В генерируемый код кое-где вставлены комментарии
- Изменен модуль "Console" в соответствии с новым способом подключения
  процедуры main()
- Изменена процедура генерации Makefile.mak в соответствии с новым способом
  подключения процедуры main()
- Изменен способ подключения процедуры main() - теперь в Console отсутствует
  вставка файла _main.h, вызов процедуры инициализации модулей - через
  зарезервированную процедуру O2M_SYS_main_init(), в перспективе - заносить
  в файл _main.cpp список процедур инициализации модулей, => убрать их вызов
  при запуске программы

Oberon2M v1.4.047
- Исправлен порядок генерации кода деклараций - теперь первыми генерируются
  импортируемые модули, затем типы, переменные, процедуры
- Символьные строки длины 1 транслируются в символьные константы

Oberon2M v1.4.048
- Изменена процедура генерации кода объявления типа массив - теперь
  поддерживаются многомерные массивы, также изменена процедура генерации кода
  переменной типа массив
- Пока поддерживается только объявление массива в декларациях TYPE

Oberon2M v1.4.049
- Реализована стандартная функция LEN

Oberon2M v1.4.050
- Исправлена генерация кода переменной типа ARRAY при объявлении переменной
  именованного типа ARRAY, объявлении переменной неименованного типа ARRAY
  (конструктор типа при оьъявлении переменной)
- Убраны некоторые неиспользуемые поля и процедуры классов CArrayType,
  CArrayVar
- Изменена логика создания переменной типа ARRAY через конструктор типов,
  теперь описание типа переменной типа ARRAY хранится в поле
  CArrayVar::ArrayType
- Расширена процедура копирования типа ARRAY CArrayType::CreateType

Oberon2M v1.4.051
- Исправлена ошибка при генерации кода параметра-переменной именованного типа
  (не ставился символ '&')
- В makefile.mak добавлена запись для компиляции _Include.cpp
- Исправлено сообщение о неверном типе выражения в размере массива

Oberon2M v1.4.052
- Изменен механизм генерации кода массивов - теперь полная поддержка передачи
  открытого и обычного массива как параметра-переменной и параметра-значения
- Изменена генерация кода оператора RETURN [Expression]
- При вызове процедур при наличии параметров-открытых массивов добавляются
  дополнительные аргументы - реальные размерности массивов
- Добавлены некоторые проверки на этапе синтаксического анализа
- Изменения в модулях в директории Import

Oberon2M v1.4.053
- Реализована стандартная процедура COPY
* Убрать повторное подключение к makefile.mak модуля, импортированного в
  нескольких модулях проекта
* Изменить десятичное задание символов на шестнадцатеричное
* Некоторые сообщения об ошибках генерируются на этапе генерации кода
  (нет номера строки) - перенести проверку на более ранний этап

Oberon2M v1.4.054
- Исправлено отсутствие проверки существования именованного типа при
  компиляции DFN файла
- Возможность явного задания имени исполняемого файла через настройки проекта

Oberon2M v1.4.055
- Реализована поддержка модуля SYSTEM
- Реализован тип PTR модуля SYSTEM (но не переменная типа PTR)
- Добавлена проверка правильности обращения в программе к вложенным записям
  переменной типа запись
- Исправлены ошибки при генерации кода процедур(-функций), связанных с типом
- Проверка экспорта связанного типа при экспорте процедуры связанной с типом

Oberon2M v1.4.056
- Изменения в логике генерации кода стандартной процедуры COPY
- Создан импортируемый модуль FileIO для работы с файлами
* Упростить извлечение переменной из выражения при генерации кода стандартной
  процедуры COPY

Oberon2M v1.4.057
- Исправлена генерация кода вызова стандартной процедуры LEN внутри процедуры
  для открытого массива
- Исправлена запись объявления экспортируемого типа массив в DFN файл
- Упорядочены тестовые примеры программ

Oberon2M v1.4.058
- Изменен способ извлечения переменной из выражения при генерации кода
  стандартной процедуры COPY
- Исправлена генерация кода стандартной процедуры DEC
- Исправлена генерация кода стандартной процедуры INC
- Реализована стандартная процедура ABS
- Исправлена ошибка при проверке количества параметров импортируемой или
  рекуррентной процедуры, теперь работает модуль "Ханойская башня"

Oberon2M v1.4.059
- Исправлена ошибка с отсутствием запятой между размерностями при записи
  описания экспортируемого многомерного массива в DFN файл
- Исправлена генерация кода операции MOD
- Исправлены некоторые несоответствия в тексте программы стандарту ANSI C++
- Убрано повторное включение в Makefile.mak файлов, которые уже были включены
  в него

Oberon2M v1.4.060
- Изменения в импортируемых модулях для создания оконного приложения Windows
  (файлы resource.rc и resource.h необходимо помещать в каталог \CPP)

Oberon2M v1.5.061
- Изменен путь для создаваемого файла со списком файлов .cpp с Make\ на CPP\
- Изменения в структуре хранения всех файлов проекта Oberon2M
- Увеличен номер версии (v1.5) - теперь данный номер версии соответствует
  общему номеру версии проекта Oberon2M (на данный момент - компилятор
  Oberon2M, генератор makefile'ов Make2M, оболочка Pro2M). Все программы версии
  1.5 имеют общую логику взаимодействия друг с другом. Последние 3 цифры (в
  данном случае 061 - номер build'а, различаются у каждой программы.

Oberon2M v1.5.062 - 12.11.01
- Исправлен глюк с включением символов '\' и '"' в строку символов
- Реализована работа с указателями на объекты
- Исправлена неправильная проверка полей записи в выражении при наличии
  базовой записи
- В некоторых случаях возможено отсутствие проверки ошибок при обращении к
  многократно вложенному полю в записи или указателе на запись

Oberon2M v1.5.063 - 14.11.01
- Исправление глюка с инициализацией ид. типа времени исполнения O2M_SYS_ID
- Исправление работы оператора WITH (не завершено)

Oberon2M v1.5.064 - 15.11.01
- Исправлена ошибка с неправильной генерацией типа приемника в экспортируемой
  процедуре, связанной с типом
- Исправлена генерация кода указателя на именованный тип (в *.cpp, *.h,
  *.dfn файлах)
- Исправлен глюк с неприятием символа '^' в выражениях с указателями
- Внесение изменений в генерацию кода оператора WITH (не завершено, статические
  члены класса не подходят)

Oberon2M v1.5.065 - 25.11.01
- Внесение изменений в генерацию кода оператора WITH (не завершено, изменения
  в генерации кода объектов)
- Исправления в генерации кода инициализации констант (исправление ошибки
  генерации "нулевых" констант)
- Проверка попытки использования импортированного только для чтения эл-та в
  левой части присваивания
- Вывод более осмысленных сообщений об ошибках в некоторых случаях вместо
  "MODULE END not found"

Oberon2M v1.5.066 - 27.11.01
- Исправление неверной обработки оператора вызова функции с нулевым числом
  формальных параметров (ошибка появилась в предыдущей версии)
- Исправление процедуры определения принадлежности id_CForwardDecl к
  процедурным типам (выражалось в неправильной обработке рекурсивных вызовов,
  ошибка проявилась в предыдущей версии)

Oberon2M v1.5.067 - 04.12.01
- Возможность передавать значение указателя в параметрах при вызове процедуры
  в качестве параметра-значения типа запись
- Операция взятия значения указателя (^) воспринимается как одноместное
  выражение

Oberon2M v1.5.068 - 06.12.01
- Возможность передавать запись и значение указателя на запись (^) в качестве
  параметра-переменной типа запись
- Исправлено отсутствие проверки импортирования типа указатель на тип без
  импортирования указываемого типа - т.е. при импорте
  ExternalType = POINTER TO SomeType
  тип SomeType тоже должен импортироваться, иначе - ошибка

Oberon2M v1.5.069 - 13.12.01
- Исправлен вылет программы при указании константы в качестве размерности
  массива

Oberon2M v1.5.070 - 13.12.01
- Исправлено отсутствие записи "VAR" в *.dfn файл для экспортируемой процедуры,
  имеющей параметр-переменную именованного типа запись

Oberon2M v1.5.071 - 21.12.01
- Добавлен поиск названий полей среди полей базового типа переменной типа
  запись при проверке обращения к полю

Oberon2M v1.5.072 - 14.01.02
- Исправлена попытка сравнения пустых строк при добавлении названия файла в
  список файлов импортированных модулей, вызывавшая ошибку
- Изменен способ инициализации ид. типа времени выполнения - создаются
  конструкторы по умолчанию для всех записей именованных типов
- Операторы WITH и IS работают с указателями на записи (пока не работают с
  параметрами-переменными типа запись), оператор WITH пока не изменяет тип
  указателя

Oberon2M v1.5.073 - 19.01.02
- Использование RuntimeId строкового типа

Oberon2M v1.5.074 - 26.01.02
- ошибка при разборе обобщающей параметрической процедуры - не проходит поиск
  специализаций
- неверный тип создаваемой парам. специализации (?)
- ошибка при компиляции выражений с указателями на массив (неверная
  интерпретация взятия эл-та ук. на массив)
- WITH не выдает ошибку при несовместимых типах указателя (а надо ли ?)
- Использование IS для проверки заведомо несовместимых типов (надо ли ?)

Oberon2M v1.5.075 - 05.02.02
- мелкие исправления
- частичная компиляция SConvertO2M (не все модули, не весь модуль Subtitles.o),
  вариант без использования параметризаций

Oberon2M v1.5.076 - 08.02.02
- Освобождение памяти массивов указателей на объекты

Oberon2M v1.5.077 - 11.02.02
- Исправление механизма работы с RuntimeId
- WITH и IS работают с параметрами-переменными типа запись
- Исправление отсутствия вставки имени модуля при генерации кода указателя на
  импортируемый тип и вызова процедуры NEW() для ук. на импортируемый тип

Oberon2M v1.5.078 - 12.02.02
- Исправления в генерации кода объявления экспортируемой переменной-указателя
- Исправление отсутствия вставки имени модуля при генерации кода указателя
  импортированного типа и вызова процедуры NEW() для ук. импортированного типа

Oberon2M v1.5.079 - 13.02.02
- Исправления в генерации кода экспортируемой переменной-указателя
  неименованного типа
- Выделение памяти под многомерные массивы (N > 1)

Oberon2M v1.5.080 - 18.02.02
- Исправления в вызове процедуры связанной с типом через указатель на RECORD
- Исправлена обработка объявления переопределенной процедуры (для одного
  модуля)

Oberon2M v1.5.081 - 14.03.02
+ Исправление оператора RETURN для процедуры - функции без параметров
+ Проверить ARRAY <...> OF _BYTE_
+ Отсутствует обработка тела обобщающей параметрической процедуры
+ Убрана проверка типа параметрического обобщения

Oberon2M v1.5.081(a,b,c,d,e) - last 10.04.02
- Реализация ППП... разными методами

Oberon2M v1.5.082 - 28.05.02
- При компиляции Release установлена опция Minimize Size (особого падения
  производительности не заметно)
- Базовый способ реализации ППП

Oberon2M v1.5.083 - 01.06.02
- Исправление обработки тела обобщенной процедуры (обработчика по умолчанию)
- Перенос объявления обобщенной процедуры ниже объявлений обработчиков парам.
  специализаций
- Включение проверки совпадения количеств обобщенных и формальных параметров
  при вызове процедуры

Oberon2M v1.5.084 - 04.06.02
- Исправлена проверка наличия возвращаемого результата функции - он может быть
  привязан как к формальным, так и к обобщенным параметрам
- Исправлена генерация подстановки переменных при вызове обработчиков внутри
  обобщенной процедуры
- Исправлено: при обнаружении ошибки в процедуре вместо строки с ошибкой
  выдавался номер строки с началом процедуры - теперь в процедуре идет проверка
  наличия описания обобщенных параметров

Oberon2M v1.5.085 - 05.06.02
- Изменена проверка наличия возвращаемого результата функции - теперь тип
  возвращаемого результата привязан только к формальным параметрам

Oberon2M v1.6.086 - 06.06.02
- Повышение номера версии
- Проверка обобщенных и формальных параметров процедуры (функции) перенесена в
  CDesignator, из CCallStatement убран CommonList
- Из CDesignator убрано поле PProcDesignator
- В CDesignator перенесена генерация кода списка параметров процедуры,
  соответственно генерация кода списка параметров убрана из CCallStatement

Oberon2M v1.6.087 - 13.06.02
- Исправлена генерация кода экспортируемой обобщенной процедуры
- Обработка вызова обобщенной процедуры в виде {a,b}.ProcName()

Oberon2M v1.6.088 - 01.07.02
- Изменение механизма генерации кода формальных параметров в .dfn файле
  (разделение генерации кода собственно параметров и типа процедуры-функции)
- Генерация кода обобщенной процедуры в .dfn файл
- Генерация кода обобщенных параметров в .dfn файл

Oberon2M v1.6.089 - 09.07.02
- В CDesignator возвращено поле PProcDesignator
  VC++ 6.0:
  в случае наличия нескольких кострукторов с различными параметрами - выдаются
  References для первого конструктора, даже если был запрос на выдачу
  References для второго конструктора ! Надо использовать пункт Calls !!!

Oberon2M v1.6.090 - 10.07.02
- Проверка в CDesignator::Init наличия вызова процедуры связанной с типом
- Проверка в CDesignator::Init указания массива-поля записи, изменен способ
  передачи переменной-массива в ExprList::WriteCPP_index
- Исправлена проверка "СommonProc := 0;" при наличии/отсутствии "()" и для
  процедур/процедур-функций

Oberon2M v1.6.091 - 15.07.02
- Изменен механизм разбора операторов - теперь вначале считывается Designator,
  затем по его полю is_proc_name проверяется наличие вызова или присвоения
- В операторе вызова проверяется отсутствие ":=" после вызова процедуры
- Проверяется наличие поля в записи при обращении к полю записи Rec.FieldName
- Исправлена генерация кода записи с полем типа массив

Oberon2M v1.6.092 - 16.07.02
- Исправлена генерация кода передачи в качестве фактического параметра (вместо
  формального параметра - открытого массива) массива-поля записи: Rec.Array
- Проверка совместимости типов формального и фактического параметров строкового
  и символьного типов
- Исправление генерации кода вызова процедуры с передачей параметра в виде
  строки символов: ProcedureCall("c")
- Базовым классом CForwardDecl сделан CProcedure (иначе требуется постоянная
  проверка name_id)
- Исправлена генерация кода вызова процедуры через ук. на тип, с которым
  связана процедура

Oberon2M v1.6.093 - 19.07.02
- Добавление кл. слова static при генерации кода типа функции (CFormalPars) для
  предотвращения конфликта имен c объектами в других модулях проекта
- Добавление кл. слова static при генерации кода глобальных переменных
- Проверка попытки экспорта локального идентификатора
- Исправление генерации кода экспортируемой переменной именованного типа запись
  (отсутствовало кл. слово extern при записи в .h файл)

Oberon2M v1.6.094 - 24.07.02
- Генерация кода стандартной процедуры-функции CAP, проверка типа передаваемого
  в данную процедуру аргумента (CHAR, "c", 99X, ARRAY OF CHAR)
- Сравнение имени главного файла, переданного через проект, с именем текущего
  компилируемого файла в UPPER CASE

Oberon2M v1.6.095 - 7.08.02
- Проверка размера массива (при генерации типа массив) - допустимы только
  ненулевые положительные целые значения размерности
- Исправление генерации кода вызова процедуры(функции) - при указании в
  качестве формального параметра открытого массива в код вызова процедуры
  теперь пишется название переменной с размерностью массива вместо "0"
- Генерация кода стандартных процедур ORD, CHR
- Классы стандартных процедур-функций переименованы в ...StdProcFunc

Oberon2M v1.6.096 - 14.08.02
- Исправление - процедуры не воспринимали указатели на массивы
- Исправление CFormalPars::WriteDFN - запись "VAR" в .DFN для параметров
  процедур

Oberon2M v1.6.097 - 20.08.02
- Исправление - при генерации кода экспортируемой переменной типа RECORD при
  генерации описания переменной не указывалось название пространства имен перед
  именем переменной
- При генерации строкового идентификатора времени исполнения O2M_SYS_ID типа
  RECORD в качестве разделителя имени типа и имени модуля используется символ
  '@' вместо '_' как принципиально недопустимый в именах символ
- Проверка экспорта переменной именованного типа без экспорта типа данной
  переменной (CIdentList::AssignVars)
- Проверка базового типа RECORD (базовым типом может быть только тип RECORD)
- Убран метод CIdentList::AssignTypes (не используется)
- Исправление - неверная генерация кода процедуры, связанной с импортированной
  переменной типа RECORD
- Устранение утечек памяти в CCapStdProcFunc::Init, CCapStdProcFunc::WriteCPP,
  COrdStdProcFunc::Init, COrdStdProcFunc::WriteCPP

Oberon2M v1.6.098 - 13.09.02
- В качестве типа CHAR использован тип "unsigned char" вместо "char"
- Изменены некоторые сообщения об ошибках (в стандартных процедурах), сокращено
  количество текстовых описаний ошибок (сокращены похожие описания)
- Изменены стандартные процедуры-функции MIN, MAX: перечислимый тип переменной
  для хранения типа аргумента функции, генерация кода

Oberon2M v1.6.099 - 30.09.02
- Тип CHAR снова интерпретируется как "char" (знаковый по умолчанию)
- Изменение стандартной процедуры-функции ORD для работы со знаковым
  представлением типа CHAR

Oberon2M v1.6.100 - 3.10.02
- Изменен способ генерации кода объявления массива - в начале генерируется код
  объявления переменной соответствующего типа (теперь WriteCPP вместо
  WriteCPP_fp), затем добавляется описание размерностей массива
- При генерации кода экспортируемой записи код поля-массива записывался в .cpp
  а не в .h файл
- Копирование Receiver->rec_name в Recv->name (иначе данная переменная
  интерпретировалась как неименованная, что неверно)
- Исправление в CExpr::FindLastName, использовано F->Designator->FindLastName()
  для обнаружения имен вида RecordName.FieldName (выражалось в неправильном
  определении типа аргумента в процедурах INC/DEC)
- Исправление генерации описания экспортируемых констант в DFN файле
- Исправление генерации кода стандартных процедур INC и DEC - использовались
  переменные только типа INTEGER
- В CDesignator::Init исправлена обработка импортированной переменной - записи
  (стоял выход из процедуры до обработки возможных символов ".", "[", "^", "(")
- Изменено сообщение об ошибке на "undeclared identifier" при указании
  необъявленного имени в качестве поля импортированной записи (указателя)
- При генерации кода строка "#include <stdlib.h>" заносится в файл _Include.h
  вместо начала модуля (иначе проблемы при подключении windows.h/wincon.h)

Oberon2M v1.6.101 - 20.10.02
- Исправление в символьных константах - интерпретировались как десятичные числа
  вместо шестнадцатеричных
- Исправление в шестнадцатеричных числах - игнорировался регистр букв A..F

Oberon2M v1.6.102 - 29.10.02
- Использование O2M_SYS_ID в типе-параметрическом обобщении (объявление
  строкового O2M_SYS_ID и его инициализация в конструкторе) при генерации кода
- Исправлена выдача сообщения о внутренней ошибке вместо сообщения об указании
  неизвестного типа при объявлении именованного типа

Oberon2M v1.6.103 - 5.11.02
- Исправление генерации кода одномерной обобщенной процедуры (лишний параметр в
  fprintf())
- Исправление - работают скалярные переменные (не отсекаются при проверке
  наличия идентификаторов и в случае поиска названий полей записи)

Oberon2M v1.6.104 - 12.11.02
- Исправление генерации кода обобщения при использовании для обобщения
  импортированных типов запись
- Исправление генерации кода процедуры, в формальных параметрах которой
  используется указатель на импортированный тип запись

Oberon2M v1.6.105 - 15.11.02
- Исправление генерации DFN для экспортируемой переменной типа POINTER
- Исправление генерации DFN для экспортируемой именованной переменной (убрана
  лишняя вставка пробела и лишняя вставка "VAR" в случае параметра-переменной
  экспортируемой процедуры (функции))
- Исправлена ошибка (Access violation) при вызове вида {ScalarVar}.CommonProc()
  (в CDesignator::FindLastName() не учитывалось возможность отсутствия
  Qualident)
- Убрано кл. слово LONG из списка перечислимых типов, используемых в
  CommonType (CCommonType::Init) - LONG это не тип!
- Добавлено кл. слово LOCAL в лексический анализатор (и в CCommonType::Init)

Oberon2M v1.6.106 - 21.11.02
- Исправление генерации DFN для обобщенного типа (CCommonType)
- Исправление CScalarVar::CreatePointerVar - при поиске имени в таблицах имен
  не указывалось название модуля
- Исправление CCommonProc::CheckParams() - при создании переменной не
  производилось копирование названия модуля, экспортировавшего тип (если оно
  было), что приводило к генерации неверного объектного кода (C++) в случае,
  если тип был импортирован

Oberon2M v1.6.107 - 27.11.02
- Исправление генерации кода при создании .h файла для обобщающего типа
  (CCommonType::WriteCPP) в случае, если используется псевдоним имени модуля,
  экспортирующего обобщаемые типы, не совпадающий с действительным названием
  модуля (данная ситуация может возникнуть при экспорте обобщения,
  использующего импортированные типы данных)

Oberon2M v1.6.108 - 04.12.02
- Изменение во всех процедурах CreateVar - добавление параметра
  "CBaseName* parent", в котором передается ук. на базовый эл-т. Также все
  процедуры изменены так, чтобы использовать данный параметр. Это необходимо,
  т.к. при объявлении переменной импортированного типа она должна иметь ссылку
  на текущий модуль, а не на модуль, экспортировавший тип

Oberon2M v1.6.109 - 30.12.02
- Исправлена запись DFN - в экспортируемые переменные попадали обработчики
  обобщенных процедур
- Исправление инициализации (Init) и генерации кода (WriteCPP) стандартной
  процедуры NEW() - неверная обработка ук. на многомерные массивы
- Исправление CFormalPars::WriteCPP_arrays - устранение утечки памяти
- Исправление генерации кода CPointerVar::WriteCPP

Oberon2M v1.6.110 - 21.01.03
- Изменение CAssignStatement::WriteCPP - убрана вставка преобразования типа для
  ук. для массив

Oberon2M v1.6.111 - 22.02.03
- Изменен код C++, генерируемый для оператора FOR (исправлена обработка
  отрицательного значения шага, доп. проверки синтаксиса, выражение TO вынесено
  в отдельную переменную для предотвращения его изменения в цикле)
- В CPP_files добавлены средства формирования отступов в файлах с кодом C++
- При генерации кода C++ проставляются вложенные отступы
- При генерации описаний C++ для записей проставляются одноуровневые отступы
- Сокращено количество сообщений, выдаваемых при удачной компиляции модуля,
  в случае ошибок во вложенных импортированных DFN модулях выдается вся
  последовательность сообщений, начиная с самого дальнего модуля. При ошибке
  в импортированном модуле дальнейшая обработка основного модуля немедленно
  прерывается. В сообщении отображается полный относительный или абсолютный
  путь к некорректному DFN модулю

Oberon2M v1.6.112 - 11.02.03
- Изменен механизм обработки параметров командной строки (возможность
  расширения набора ключей транслятора), добавлены ключи -?, -d (запрет вывода
  информации о программе), -f <file> (указание файла для записи сообщений
  транслятора). Изменена справочная информация, выводимая по -?
- В объекты, формирующие выражение (CExpr, CSimpleExpr, CTerm, CFactor)
  добавлены процедуры (CalcResultId, GetResultId) для вычисления результата
  выражения
- Добавлен базовый класс CStdProcFunc для стандартных процедур-функций,
  содержащий метод GetResultId
- Во всех стандартных процедурах-функциях прописан тип возвращаемого результата
  (выдается методом GetResultId)
- Закомментирован отладочный метод debug_PutsDeclSeq() в CDeclSeq

Oberon2M v1.6.113 - 18.03.03
- Доработки в механизме проверки совместимости выражений
- Убран метод CSimpleExpr::CalcResultId за ненадобностью (все перенесено в
  CSimpleExpr::Init)
- Исправлено CLenStdProcFunc::Init - в случае одного аргумента не
  инициализировался ResultId
- Создан GetResultId для CDesignator

Oberon2M v1.6.114 - 25.03.03
- Изменена логика проверки количества измерений массива в CDesignator и при
  определении типа результата выражения (CArrayVar::GetResultId(int dimension))
- В CExpr метод FindLastName заменен на FindLastVar, проверяющий в т.ч. и
  возврат выражением l-value
- Изменен способ проверки типа аргументов (в т.ч. l-value) в стандартных
  процедурах и процедурах-функциях

Oberon2M v1.6.115 - 28.03.03
- Рассмотрение числовых констант как имеющих минимальный тип, достаточный для
  хранения указанного числового значения
- Оптимизация обработки вызовов процедур
- Процедуры is_var_id, is_var_digit_id, is_var_int_id, is_var_real_id,
  is_type_id, is_proc_id заменены статическими методами соответствующих классов
- Определение типа результата выражения в виде переменной происходит в методе
  CBaseType::GetResultId
- Исправлена неверная генерация кода SHORTINT константы
- Исправлена генерация кода ASSERT (неверное условие прерывания программы),
  ABS (неверная обработка действительного аргумента), ENTIER (реализована как
  вызов "floor"), LEN (оптимизация), MAX, MIN (стояло "%d" вместо "%g", в MIN
  для int и long надо писать (-MIN - 1)), SIZE (убрана выдача размеров для не
  типов)
- Исправлена CLenStdProcFunc::Init (потенциальная утечка памяти)
- При генерации файла "_Include.h" (подключается ко всем модулям) добавлены
  импорт стандартной библиотеки "math.h" (используется в исправленных ABS,
  ENTIER)
- Различные оптимизации

Oberon2M v1.6.116 - 31.03.03
- Функция ConstSelector для упрощения проверки констант
- Изменение генерации кода ASSERT (оптимизация), EXCL (исправление), HALT
  (возврат в систему целого значения), EXCL (исправление)
- Исправление инициализации NEW (потенциальная утечка памяти)
- Оптимизация инициализации CForStatement
- Оптимизация CDeclSeq::ConstInit
- Определение типа выражения в случае использования ссылки через указатель (p^)

Oberon2M v1.6.117 - 09.04.03
- Исправление EXCL (генерация кода, код ошибки при проверке 1-го параметра)
- Исправление INCL (генерация кода, код ошибки при проверке 1-го параметра)
- Исправление генерации кода операций со множествами (IN, +, -, *, /)
- Исправление вычисления типа результата операции '/' над множествами
- В "_Include.h" и "_Include.cpp" добавлена процедура O2M_SET_RANGE для
  вычисления диапазона в формате SET для Oberon2M
- Оптимизирован конструктор множества - все возможные вычисления промежуточных
  множеств выполняются на этапе компиляции

Oberon2M v1.6.118 - 18.04.03
- Исправлен и оптимизирован CASE (некорректно проверялись пустые Case, не
  распознавались некоторые ошибки (например, повторное объявление меток))

Oberon2M v1.6.119 - 19.04.03
- Исправлен CASE (не проверялось повторное объявление метки в одном Case)
- Исправлен ASSERT (не проверялся тип первого выражения)
- Исправлен UNTIL (не проверялся тип выражения)
- Исправлен IF (не проверялся тип выражений)
- Исправлен WHILE (не проверялся тип выражения)

Oberon2M v1.6.120 - 29.04.03
- Исправлен EXIT, изменение генерации кода для LOOP, EXIT (не проверялось
  использование EXIT в не LOOP циклах)

Oberon2M v1.6.121 - 03.05.03
- Вычисление констант для стандартных процедур-функций:
  ABS, ASH, CAP, CHR, ENTIER, LEN, LONG, MAX, MIN, ORD, SHORT, SIZE
- При генерации кода для записи значений переменных INTEGER и LONGINT, имеющих
  минимально допустимые значения, запись производится в виде ((Value + 1) - 1)
  (не критично, просто уменьшает количество warning-ов)

Oberon2M v1.6.122 - 07.05.03
- Исправлен некорректный поиск импортированных имен в импортированных модулях
  (теперь при обработке каждого DFN модуля поиск импортированных переменных
  ведется только в пространстве имен данного модуля)
- Исправление генерации кода объявления указателя - для указателей типа
  QualidentType записывалось действительное имя типа вместо имени из
  QualidentType
- Исправление NEW - терялось имя модуля в случае импортированного указателя

Oberon2M v1.6.123 - 08.05.03
- Исправлена инициализация Qualident - при Name.10 (недопустимый второй
  идентификатор) возникало два указателя на одну и ту же строку
- Исправлена инициализация CQualidentType - проверяется наличие имени типа
- Изменен текст сообщения об ошибке для: s_e_RecordField, s_e_FOR_assume,
  s_e_TO, s_e_ProcedureSemicolon, s_e_SIZE_ParamNotType
- Вместо s_e_Designator_ident везде используется s_e_UndeclaredIdent (сообщение
  "Undeclared identifier")
- Вместо s_e_Qualident везде используется s_e_IdentExpected (сообщение
  "Identifier expected")
- Убран s_e_PointerTo, вместо него используется s_e_TO
- Убран s_e_FOR_ident, вместо него используется s_e_FOR_ident_NotInt
- Изменен CQualident::Init - для простых типов расчет TypeResultId ведется
  сразу
- Вместо CQualident::debug_Assign_type_id используется
  CQualident::CalcTypeResultId, в котором сразу проверяется наличие типа
- В FOR проверяется наличие и тип переменной цикла
- Исправление генерации кода процедурного типа, типа SET
- Исправление записи в DFN для процедурного типа (CProcedureType::WriteDFN)
- Изменение CQualident:: WriteCPP (заменен на WriteCPP_type) и WriteDFN
- Незначительные изменения в оформлении генерируемого кода и DFN файлов

Oberon2M v1.6.124 - 09.05.03
- Везде, где используется parent_element, он объявлен как const CBaseName*
- Часть методов, не изменяющих состояние объектов, объявлены с суффиксом const
- В методы CBaseName:: (FindName, AddName, DeleteName) вставлены исключения -
  эти методы могут быть вызваны только в классах, которые их перекрывают,
  добавлен метод CArrayType::FindName для перекрытия CBaseName::FindName
- Изменение инициализации CPointerType - в случае неименованного типа (массив
  или запись) или именованного и уже описанного типа осуществляется проверка
  корректности типа. Если тип именован и еще не описан, проверка откладывается

Oberon2M v1.6.125 - 10.05.2003
- Изменение работы контейнера лексем - оптимизация, сохранение информации о
  позиции лексемы в строке в исходном файле
- Определение номера текущей строки ведется только через CLexBuf::GetCurrStNum
- Изменение всех методов и процедур для работы с обновленным контейнером лексем
- Макрос "DECL_BUF" везде заменен на "CLexInfo li;"
- Выводится позиция ошибки в строке (без учета табуляций), изменены тексты
  сообщений об ошибке, в том числе: l_e_OpenComment, s_e_MODULE_END_name,
  s_e_ProcedureEndName

Oberon2M v1.6.126 - 11.05.2003
- Оптимизация лексического анализатора, вычисление позиции лексем в строке с
  учетом табуляций
- Задание размера табуляции в командной строке (ключ -t)

Oberon2M v1.6.127 - 13.05.2003
- Убраны из проекта файлы IO_proc.cpp, IO_proc.h. Все, что связано с
  лексическим анализом, перенесено в LexAnl.cpp, LexAnl.h
- Вместо s_e_ConstSemicolon, s_e_TypeSemicolon, s_e_VarSemicolon используется
  s_e_SemicolonMissing
- Убрана проверка экспорта типа в случае экспорта процедуры (возможен экспорт
  переменной данного типа, через которую можно вызвать процедуру)
- Изменен контейнер лексем - для ключевых слов сохраняется только перечислимый
  тип ключевого слова. Изменены все процедуры, использующие лексемы
- Все процедуры, выполняющие лексический анализ, собраны в класс CLexBuf
- Исправлено распознавание ключа t (не определялся), значение табуляции по
  умолчанию установлено равным 1

Oberon2M v1.6.128 - 16.05.2003
- Исправлен CASE - пропускался список Case-ов, исправлена потенциальная утечка
  памяти, оптимизация
- Все WriteCPP ничего не возвращают (void)
- test_digit и test_keyword объявлены как inline
- При генерации кода типа TYPE AnyName = POINTER TO RECORD ... генерируется
  код типа RECORD, которому назначается имя AnyName
- Изменен текст сообщения об ошибке для: s_e_Redefinition, s_e_MODULE, вместо
  s_e_WHILE_DO, s_e_FOR_DO и s_e_GUARD_DO используется s_e_DO

Oberon2M v1.6.129 - 21.05.2003
- Убрана проверка экспорта переменной без экспорта ее именованного типа
- GetResultId(int dimension) перенесен из CArrayVar в CArrayType
- Вместо s_e_NEW_UnknownIdent используется s_e_UndeclaredIdent
- Используется CPointerVar->FindType() для работы с ук. на RECORD,
  соответственно изменена логика работы класса CPointerVar, убран метод
  CPointerVar::GetTypeModuleName()
- Изменена генерация кода NEW() с учетом использования CPointerVar->FindType()
- Изменение справочной информации (ключ "-a" вместо "-d", расширения изменены
  с ".o" на ".o2m")
- Код всех глобальных типов пишется в .h файл, т.к. они могут использоваться
  при экспорте переменных
- Проверка наибольшего целого числа, сообщение об ошибке l_e_NumberTooLarge
- Метод Assign из IdentDef перенесен в CBaseName и теперь также используется
  при создании копий переменных (CBaseVar::CreateCopyVar)
- Незначительные изменения в оформлении DFN файла
- Найдено еще несколько процедур WriteCPP..., возвращавших некоторое значение,
  все переделано в void
- Инициализация name_id происходит в CBaseName, в который передаются все
  name_id через списки инициализаций
- Исправление метода вычисления типа результата по указанному измерению массива
  (не учитывалась возможность появления QualidentType)
- В качестве типа процедуры, возвращающей указатель, используется тип указателя
  (было "void*")
- Генерация кода опережающего описания типа RECORD при объявлении ук. на еще не
  объявленный тип

Oberon2M v1.6.130 - 22.05.2003
- Вместо s_e_RecvTypeNotRecPoint, s_e_RecvTypeVarPointer, s_e_RecvTypeNotVar
  используется s_e_ReceiverVAR;
  вместо s_e_Receiver, s_e_ReceiverName, s_e_ReceiverType
  используется s_e_IdentExpected;
  вместо s_e_ReceiverColon, s_e_GUARD_Colon, s_e_Colon, s_e_FPSection_colon
  используется s_e_ColonMissing;
  вместо s_e_ImportList_semicolon,  s_e_ProcedureEndSemicolon,
  s_e_ProcedureSemicolon, s_e_MODULE_semicolon
  используется s_e_SemicolonMissing;
  вместо s_e_ReceiverTypeDecl используется s_e_UndeclaredIdent;
- Исправления в классе CReceiver (оптимизация, генерация "*" для указателя)

Oberon2M v1.6.131 - 23.05.2003
- Вместо s_e_GUARD_UnknownVarName, s_e_GUARD_UnknownTypeName
  используется s_e_UndeclaredIdent;
- Изменения в логике работы CWithStatement, CGuard, CGuardPair
- В WithLoopLink создана таблица имен (из одного эл-та)
- Исправление CReceiver - VAR записи являются указателями ("*") а не ссылками,
  внесены соответствующие изменения при генерации кода
- При генерации кода подстановки параметров при вызове процедуры
  (CExprList::WriteCPP_proc_OpenArr) проверяется наличие параметра-переменной
  типа запись и подстановка "&" при необходимости

Oberon2M v1.6.132 - 03.06.2003
- Убрано добавление лишнего "&" для параметров-переменных при генерации кода в
  CDesignator::WriteCPP
- Исправлена генерация кода типа массив (теперь аналогично типу указатель)
- Введена проверка допустимости использования открытых массивов
- Вместо s_e_TypeEqual, s_e_ConstEqual используется s_e_EqualSignExpected;
  вместо s_e_AssignAbsent, s_e_FOR_assume используется s_e_AssignMissing;
  вместо s_e_MODULE_END, s_e_ProcedureEnd, s_e_FOR_END, s_e_RecordEnd,
  s_e_LOOP_END, s_e_WHILE_END, s_e_IF_END, s_e_CASE_END, s_e_WITH_END
  используется s_e_END;
  вместо s_e_ProcedureName используется s_e_IdentExpected;
  вместо s_e_CASE_OF, s_e_ArrayOf используется s_e_OF;
  вместо s_e_IF_THEN, s_e_ELSIF_THEN используется s_e_THEN
- Убран метод Init у переменных - наследников CBaseVar (не используется)
- Файлы TypeVar.cpp, TypeVar.h разделены на Type.cpp, Type.h и Var.cpp, Var.h

Oberon2M v1.6.133 - 10.06.2003
- В CExprList::WriteCPP_proc_OneParam при проверке необходимости записи "&"
  проверяется тип не только формального, но и фактического параметра,
  используется CExpr::FindLastVar

Oberon2M v1.6.134 - 23.06.2003
- Оптимизация CExprList::WriteCPP_proc_OneParam
- Проверка допустимости размера табуляции, значение по умолчанию: 1 (было 0)
- Изменение CReturnStatement::Init - более точное позиционирование на ошибку,
  вывод сведений об ошибке в выражении вместо сообщения об отсутствии выражения
- Исправление CQualident::CreateCopy - не копировался TypeResultId
- Создан метод CFormalPars->CreateCopy, данный метод использован в
  CForwardDecl::InitRecurrent (где не копировался CFormalPars::Qualident)
- CBaseName::Assign, CBaseVar::CreateCopyVar, CBaseType::CreateType,
  CBaseType::CreateVar, CQualident::CreateCopy - объявлены как const

Oberon2M v1.6.135 - 07.07.2003
- Сведения о программе сдвинуты на 1 строку вниз, в примере ключ "-d" заменен на "-a"
- Переменная output объявлена как глобальная (исправлен вывод сообщений по ключу "-f")
- Исправлено сообщение "Incorrect symbol symbol", "Compilator" исправлено на "Compiler"
- Исправлено - для некоторых лексических ошибок неверно рассчитывалась позиция в строке
- Убрана функция ReadSt за ненадобностью
- Изменен механизм загрузки файла проекта - оптимизация, обработка кавычек, распознавание
  TABSIZE
- Исправлена инициализация многомерного массива записей (стоял неверный parent_element)
- В CExprList::WriteCPP_proc_OneParam добавлена генерация кода приведения типа для
  открытых массивов (необходимо для многомерных открытых массивов)
- В CExpr::FindLastVar() введена проверка BV на NULL (?!)
- Исправлена генерация кода переменной - ук. на неименованный тип (некорректно
  подставлялось "static")

Версия Oberon2M v1.6.135 демонстрировалась на конференции
===============================================================================

Введены обозначения в файле истории:
! важное замечание
+ реализация новой возможности
- исправление ошибки
* изменение


Oberon2M v1.7.136 - 17.07.2003
! Повышение номера версии
* Устранены несоответствия c ANSI C++ (теперь компилируется под MinGW (gcc 2.95.3-6))
+ Изменен файл для запуска gcc - добавлены ключи оптимизации
- CBaseVar::SetTypeName - некорректно удалялось существующее имя типа
* Для установки имени в наследниках CBaseName используется метод SetName
* При генерации исключения error_Internal везде указывается только текст, необходимый
  для идентификации исключения (убраны комментарии о причине генерации исключения)
- Генерация DFN для массива неименованных записей
* Реализованы статические функции для получения названий типов в C++ (через класс или
  путем указания ResultId), получение названий типов - только через данные функции
* В CProcedureType теперь FormalPars не является указателем, убран деструктор
+ Доработка CProcedureVar - теперь нормально генерируется код описания процедурной
  переменной
* В CFormalPars вместо метода CreateCopy создан метод Assign (копирование содержимого)
* Изменение CExprList::WriteCPP_proc_OneParam - в параметрах вызова передается только
  интерфейс к файлам, выражение факт. параметра и формальный параметр
* Вместо s_e_LEN_ArrName, s_e_LEN_NameNotArrVar используется s_e_LEN_NoArray;
  вместо s_e_StdProcBegBracket, s_e_StdProcFuncBegBracket
  используется s_e_OpBracketMissing;
  вместо s_e_StdProcEndBracket, s_e_StdProcFuncEndBracket, s_e_RecordEndBracket,
  s_e_ReceiverEndBracket, s_e_Call_EndBracket, s_e_Factor_ExprEndBracket,
  s_e_Factor_DesEndBracket, s_e_FormalParsEndBracket, s_e_Designator_EndBracket
  используется s_e_ClBracketMissing;
  вместо s_e_Set_EndBrace используется s_e_ClBraceMissing;
  вместо s_e_Designator_EndSqBracket используется s_e_ClSquareMissing;
+ Реализован механизм интерпретации выражения в зависимости от контекста, корректная
  обработка строковой константы размером 1 символ как строки или символа в зависимости от
  контекста, исправлены ст. процедуры CAP, ORD, оператор RETURN
- Стандартная функция LEN работает со строками (длиннее 1 символа)
- Вычисление совместимости выражений при наличии унарного '+' или '-'
* Механизм определения l-value (FindLastVar)
+ Реализован вызов процедуры(функции) через процедурную переменную
* Метод CBaseName::GetResultId помечен как константный (также у всех наследников)


Oberon2M v1.7.137 - 27.07.2003
* В CDesignator вместо ук. на процедуру оставлен только признак нахождения в фактических
  параметрах вызываемой процедуры
* Убраны: s_e_FormalParIncompatibleType, s_e_CallProcName,
  CExprList::Expr, CExprList::AddExpr
* Вместо CExprList::PProcDesignator используется CExprList::PFP
* WriteCPP_type_name переименовано в WriteCPP_fp_named_type,
  WriteDFN_type_name переименовано в WriteDFN_named_type
* В механизме расчета констант разделено создание копий переменных и создание констант
* Некоторые методы и структуры данных переименованы в нечто более логичное
* Убраны некоторые неиспользуемые методы и типы (вектора)
* Доработка механизма вычисления констант, в коде записываются только полностью
  рассчитанные значения
* Признак указываемой переменной ("^") обрабатывается в CDesignator, а не в CExpr
* Вместо s_e_CommonProcCallName используется s_e_CallNotProc
* Список фактических параметров (и обычных и обобщенных) перенесен из CDesignator в
  CCallStatement, сам CCallStatement перенесен в "Expr.cpp" (т.к. теперь он используется
  в CFactor), убран метод CDesignator::WriteCPP_proc (не используется)
- Объявление константного указателя со значением NIL
- Символьная константа в качестве фактического параметра для открытого массива
  при генерации кода преобразуется в символьный массив
- Вычисление совместимости выражений при наличии унарного '~'
- Генерация кода конструктора пустого множества, генерация кода константного множества
- При инициализации констант устанавливаются признаки константности, теперь не должно
  быть случаев пропуска попыток использования переменных при объявлении констант
- В CDesignator::Init при наличии селекторов вложенных записей ('.') проверка последнего
  объекта в цепочке происходит на общих основаниях
- В CFPSection::AssignFPElems во всех случаях проверяется наличие идентификатора
- Операции MOD и DIV работают как в Обероне-2 (строго говоря, как в BlackBox)
- Генерация кода символьной константы ("CONST ch = CHR(38);")
+ Обработка всех вызовов (процедур, функций, параметрических процедур и функций) как в
  CStatementSeq так и в CFactor возложена на CCallStatement
+ Проверка вызова функции как процедуры, наличия "()" при вызове функции без параметров
+ Проверка наличия "()" при объявлении процедуры-функции без параметров
+ Вычисление константного значения конструктора множества, теперь в константе пишется
  только вычисленное значение
+ Добавлены s_e_Incompatible, s_e_DivisionByZero, s_e_CallFuncAsProc
+ В _Include.* добавлены "#include <ctype.h>" (для "toupper()") и функция MOD
+ Инициализация процедурной переменной через присваивание, в параметрах процедуры


Oberon2M v1.7.138 - 09.08.2003
* Некоторые методы и структуры данных переименованы в нечто более логичное
* Убраны некоторые неиспользуемые методы и типы (вектора)
* Вместо s_e_Pointer_VarNotPointer используется s_e_DesNotPointer;
  Вместо s_e_Array_VarNotArray используется s_e_DesNotArray;
  Вместо s_e_GUARD_TypeVarName используется s_e_GuardNotVRecOrP;
  Вместо s_e_COPY_SecondArgNotName используется s_e_OperandInappl;
  Вместо s_e_LEN_DimentionValue используется s_e_LEN_Dimension;
  Вместо s_e_MAX(MIN)_ArgNotType используется s_e_MAX(MIN)_NotType;
  Вместо s_e_SIZE_ParamNotType используется s_e_SIZE_NotType;
  Вместо s_e_ForwardDecl используется s_e_ForwardDeclUnsat;
  Убраны s_e_Array_IndexesCount, s_e_COPY_AbsentSecondArg, s_e_DEC_FirstArgVar,
    s_e_DEC_FirstArgType, s_e_DEC_SecondArgType, s_e_EXCL_FirstArgVar,
    s_e_EXCL_FirstArgType, s_e_EXCL_AbsentSecondArg, s_e_EXCL_SecondArgType,
    s_e_HALT_SecondParam, s_e_INCL_FirstArgVar, s_e_INCL_FirstArgType,
    s_e_INCL_AbsentSecondArg, s_e_INCL_SecondArgType, s_e_INC_FirstArgVar,
    s_e_INC_FirstArgType, s_e_INC_SecondArgType, s_e_FormalParsCount, s_e_ASH_Comma,
    s_e_ABS_ParamNotNumber, s_e_ASH_FirstParamNotInt, s_e_CAP_ArgType,
    s_e_ASH_SecondParamNotInt, s_e_CHR_ParamNotInt, s_e_ENTIER_ParamNotRealType,
    s_e_LONG_IncorrectParam, s_e_ODD_ParamNotIntType, s_e_ORD_ParamNotCharType,
    s_e_SHORT_IncorrectParam, s_e_ForwardDeclName, s_e_ProcedureRedefined,
    s_e_ForwardDeclRedefined
* Изменение механизма инициализации CDesignator, класс CRecordRef больше не используется,
  ExprList больше не хранится непосредственно в CDesignator (теперь он в DesElem),
  устранены несоответствия разбора обозначения стандарту языка
* Изменение механизма проверки l-value и read-only - внесены необходимые изменения
  во все объекты, требующие получения l-value
* Изменение механизма проверки рекурсивного вызова за счет изменения механизма поиска
  имени в таблице имен процедуры
* Локальные процедуры помещаются в неименованное namespace вместо использования static
* Процедуры, связанные с типами, теперь рассматриваются как методы класса RECORD при
  генерации кода
* Убран метод DeleteName за ненадобностью из CDeclSeq, CRecordType,CBaseName и всех
  наследников, вместо std::list везде используется std::vector
- Вычисление ResultId в переопределенных методах CQualidentType::GetResultId(),
  CProcedureType::GetResultId()
- В NEW(..) первый параметр рассматривается как выражение (CExpr) а не как CQualident
- WITH работает во всех случаях (импортированные и локальные имена переменных,
  импортированные и локальные имена типов), изменения в CDesignator, CGuard,
  CBaseVar (введен признак is_guarded), GetGlobalName
- В CRecordType::FindName производится поиск имен как среди собственных членов, так и
  среди членов базового типа
- В CArrayType::GetType правильно подсчитывается номер размерности при поиске типа
- В CFactor::FindLastVar учитывается возможность вхождения в Factor выражения
- Проверяется установка '-' (признак read-only) у объектов, отличных от переменных и
  полей записи, сам признак перенесен из CBaseName в CBaseVar
- Ст. процедуры MAX и MIN работают с именованными типами, упрощены
- Генерируется код опережающих описаний
+ Добавлены s_e_DesNotRecord, s_e_IdentWrongMarked, s_e_OperandNotVariable,
  s_e_OperandReadOnly, s_e_ParsFewer, s_e_ParsMore, s_e_CommaMissing,
  s_e_ParamNotIntConst, s_e_ParamNotMatch
+ Добавлен метод CPointerVar::FindName для упрощения поиска имен через ук. на запись
+ В CExpr (а также в CSimpleExpr, CTerm, CFactor) добавлен метод IsReadOnly, метод
  FindLastVar преобразован в FindLastName (может возвращать наследников CBaseType),
  в CExpr добавлен FindLValue - для быстрого получения l-value (без проверки read-only)
+ Механизм проверки опережающих описаний процедур сделан независимым от процедуры,
  убрана необходимость уничтожения имен в таблицах имен, поддерживаются множественные
  опережающие описания


Oberon2M v1.7.139 - 22.08.2003
* Некоторые методы и структуры данных переименованы в нечто более логичное
* Вместо s_e_QualidentNotType используется s_e_IdentNotType;
* Убран s_e_GUARD_TypeTypeName
* Добавлены s_e_GuardTypeNotP, s_e_GuardTypeNotRec, s_e_GuardTypeNotExt
* CGuard::Init - изменены сообщения об ошибках при инициализации оператора WITH
- Установка имени типа в методах <Тип>::CreateVar - в связанной с типом процедуре
  можно вызавать другие связанные с этим же типом процедуры через приемник
- CDesignator::Init и CDesignator::FindLastName - корректно обрабатывается обращение
  к полю записи в случае массива ук. на запись
- CPointerType::Init - исправлен механизм поиска типа, на кот. указывает указатель
  (CPointerType::FindType), теперь допускается использование в ук. именованного типа
- Код вызова "NEW" для импортированного указателя - при генерации "new" для типа
  импортированного ук. пишется имя модуля (берется через parent_element переменной),
  генерируется код выделения памяти для ук. на неименованный тип (используется
  искусственное имя)
- Добавлен метод CDesignator::WriteCPP_Guardless, исправлен CDesignator::WriteCPP,
  теперь при присвоении охраняемой переменной значения не генерируется код охраны
  типа (вызывало ошибку при компиляции C++ кода внутри WITH)
+ Механизм проверки наличия (и допустимости) типа в объявлении ук. вида
  POINTER TO SomeType, где SomeType еще не объявлен (используется в типах, переменных
  и формальных параметрах для записей, указателей и массивов)


Oberon2M v1.7.140 - 01.09.2003
* CDeclSeq::WriteCPP_var - изменен метод генерации кода переменных
* Убран CBaseVar::WriteCPP_if_global, вместо "static" используется "namespace {...}",
  необходимый код генерируется в CDeclSeq::WriteCPP_var
* В CBaseVar::GetTypeModuleName в случае импортированной переменной сразу подставляется
  алиас модуля, который ее экспортирует, если имя модуля с типом не указано явно
  (т.к. в данном случае тип объявлен в том же модуле, что и переменная)
* NEW - упрощена генерация кода с учетом изменений в CBaseVar::GetTypeModuleName
* В обобщении вместо "RECORD CASE ..." используется "CASE ..."
* В CRecordVar::CheckComplete проверка осуществляется только для переменных
  неимпортированного типа (т.к. проверка импортированного типа выполняется еще в DFN)
- Добавляется "::" при использовании пространства имен в генерируемом коде
- В CGuard устанавливается признак переменной, созданной через QualidentType
  (необходимо для поиска полей записи), и признак переменной-ук. на запись
- Код охраны типа в левой части выражения не генерируется только при присвоении
  непосредственно указателю
- Обработка последнего символа '^' в обозначениях (CDesignator) - разыменование
  эл-та при генерации кода
- Обрабатывается рекурсивное объявление ук. на запись внутри этой же записи
  (не работало после введения механизма проверки наличия указываемого типа)
- При генерации кода массива записей подставляется "." вместо "->"
- В CBaseType::GetModuleName используется алиас, а не действительное имя модуля
- В CPointerVar::CreateVar копировались не все необходимые атрибуты переменной
- В CBaseVar::GetTypeModuleName обрабатывается случай поля импортированной записи
+ Добавлен CBaseType::IsSame (проверка одинаковости типов)
+ В WITH введена проверка, является ли указанный в охране тип расширением статического
  типа охраняемой переменной


O2M v1.7.141 - 16.09.2003
! Проект переименован в O2M, убраны все ссылки на название Oberon2M
* Некоторые методы и структуры данных переименованы в нечто более логичное
- При генерации кода записей вначале генерируется объявление записи, и только в конце
  объявления типов гнерируются описания записей. Вызвано тем, что в связанных с типом
  процедурах могут использоваться записи, объявленные позже, чем тип, с которым
  связаны процедуры
- При записи кода в .h файл используется имя, а не псевдоним модуля, при записи кода
  в .cpp файл используется псевдоним, а не имя модуля
- При создании переменной по типу (CreateVar) используется имя, а не псевдоним модуля
- При генерации кода инициализации массивов (в процедурах) перед типом эл-тов массива
  добавляется уточнение (псевдоним модуля, экспортировавшего данный тип) если надо
- При генерации кода сигнатур и вызовов процедур в случае импортированного типа эл-тов
  параметра - открытого массива генерируется уточнение имени (имя или псевдоним модуля)
+ Метод CBaseName::GetParentModule для получения верхнего в иерархии модуля


O2M v1.7.142 - 23.10.2003
* Файлы SRC_Incl.cpp и SRC_Incl.h переименованы в SRC_sys.cpp и SRC_sys.h
* Генерируемый файлы _Include.* и _main.* переименованы в _O2M_sys.* и _O2M_main.*
* Makefile.txt переименован в _O2M_make.2mk
* Файлы *.fpp переименованы в *.2ml, формат файлов изменен на xml v1.0
* Вместо s_e_CommonTypeOf используется s_e_OF
* CScalarType переименован в CSpecType, используется только при SomeType = Summ<param>;
* Изменен механизм записи комментариев в создаваемые компилятором файлы
* Убран CQualident::CalcTypeResultId, вместо него реализован Qualident::InitTypeName
  для инициализации имени типа, Init используется для не имени типа
* Убраны s_e_CommonTypeList, s_e_CommonTypeParam, s_e_PointerType
- Исправлено Dmitriy на Dmitry
- Правильное вычисление SHORTINT, REAL, LONGREAL констант в случае унарного минуса
- Исправлена генерация кода для "pointer^" в параметрах вызываемой процедуры
- Генерация объявления типа - указателя на массив и переменной - указателя на массив
  в DFN файле
- В лексическом анализаторе символы ".=" воспринимались как лексема ".."
- В CCallStatement::InitProcCommonPars выводилось '")" missing' вместо '"}" missing'
- Генерация кода поля записи - неим. ук. на неим. массив
- CFPSection::CFPSection - очистка списка строк в конструкторе вместо деструктора
+ Добавлена лексема "+=", обработка расширения - в CDeclSeq::TypeInit
+ Используется доработанный вариант класса CCommonType


O2M v1.7.143 - 28.10.2003
! Файл "_O2M_make.2mk" (O2M makefile) генерируется в xml формате, на этот формат
  теперь ориентируются Link2M и Make2M
* Вместо Growth для расширения обобщения используется Extension
* Текст всех сообщений об ошибках приведен в соответствие с BlackBox
* CIdentDef::Init - используется s_e_IdentExpected вместо s_e_IdentDef
* CDeclSeq::TypeInit - при инициализации CIdentDef проверяется наличие возвращения
  s_e_IdentExpected (признак отсутствия идентификатора) вместо его отсутствия
* CCommonType больше не является наследником от CRecordType
- В процедурах (всех видов) возвращается ошибка, получаемая в CIdentDef::Init вместо
  s_e_IdentExpected (терялись ошибки s_e_IdentWrongMarked и другие)
- Разбор признака - уточненного имени (Qualident) при обработке специализации
+ Разбор параметризаций обобщений в объекте CIdentDef


O2M v1.7.144 - 2004.01.13
! В файлы _O2M_sys.h и _O2M_main.cpp включены ссылки на _O2M_ppp.h и _O2M_ppp.cpp
  соответственно, генерируемые утилитой Link2M v002 или выше
! Убрана генерация Makefile.mak, вся информация, необходимая для работы Link2M и
  Make2M, записывается в _O2M_make.2mk в XML формате
* Сохранение имени признака в CScalarType, убрано лишнее поле
* При работе с обобщенными переменными везде используется CCommonVar
* Больше не используется CScalarVar, тип CScalarType используется для создания
  переменной CCommonVar, в которую заносится имя признака
* Генерация кода объявления обобщенной переменной, специализированной конкретным
  типом, с учетом механизма поддержки обобщений, введенного в Link2M v002
+ Добавлен ключ отображения номера версии (-v)
+ В файл _O2M_make.2mk заносится имя главного модуля проекта (для Make2M)
+ Реализован поиск полей у специализированных обобщенных переменных
- Запись в .2ml файл расширения импортированного обобщения
- При генерации объявления обобщения в DFN файле не генерировались ELSE и END
- Убрано "::" перед названием пространства имен в процедуре инициализации модуля
  (вызывало ошибку компиляции в GNU C++)


O2M v1.7.145 - 2004.01.23
! В CCommonProc генерируется код обращения к таблице адресов обработчиков парам.
  спец-ций через служебную функцию, генерируемую утилитой Link2M v003 или выше
* Изменена генерация кода названия обработчика параметрической специализации
  (CHandlerProc) для использования в служебной функции, работающей с таблицей
  адресов обработчиков параметрических специализаций
* Из CCommonProc убран неиспользуемый код
* Код обработчика парам. спец-ции всегда генерируется как для экспортируемой
  процедуры для обеспечения видимости обработчика за пределами модуля
* В .2ml файл не записывается информация об отсутствии обработчика по умолчанию
* Изменения в методе CDfnProcedure::Init (доработка, оптимизация)
+ Запись информации об обобщенных процедурах и обработчиках в .2ml файл
+ Создан класс CDfnCommonProc для разбора обобщенной процедуры в DFN модуле
- Корректная генерация объявления обобщенной процедуры в DFN
- В CDfnDeclSeq::Init обрабатывается объявление обобщенной процедуры
- Генерация кода обращения к полю специализированной обобщенной переменной
- Обрабатывается обращение к обобщенной переменной - полю записи
- Исправлена CCommonType::FindSpec - в качестве параметров принимаются и имя
  типа, и название признака
- Генерация кода обработчика параметрической специализации
- Убрано "::" перед названием пространства имен в коде описания процедуры
  (вызывало ошибку компиляции в GNU C++)
- Проверка, является ли обобщенная переменная VAR-параметром
- Убран вызов метода CHandlerProc::WriteDFN


O2M v1.7.146 - 2004.01.27
! При описании обработчиков парам. спец-ций, привязанных к импортированным
  обобщенным процедурам, указывается имя (псевдоним) модуля, экспортирующего
  обобщенную процедуру: "PROCEDURE Module.CommonProcName ...", данное имя заносится
  в .2ml файл, что требует использования Link2M v004 или выше
* Запрещено использование меток экспорта для обработчиков парам. спец-ций
* Более подробные сообщения об ошибках при вызове обобщенных процедур
* Убран код для работы с приемником у обобщенных процедур и обработчиков
+ Дополнительные проверки при использовании тэга в специализируемой переменной
- В формальных параметрах обработчиков параметрических специализаций
  обрабатывается объявление параметров в виде "ParamName<Tag> : CommonType"
- Корректные позиция и текст сообщения об ошибке при совпадении имени формального
  параметра и имени приемника в процедуре, связанной с типом


O2M v1.7.147 - 2004.02.01
* В ст. процедуре NEW использунтся CDesignator для получения имени указателя
+ Стандартная процедура NEW работает с указателями на обобщения
+ Дополнительные проверки и сообщения об ошибках при работе с командной строкой
- В CBaseType::GetResultId() определяется тип результата для обобщения
- Исправлена генерация кода обобщенной переменной в DFN файле
- При поиске типа специализации в обобщенной переменной (CCommonVar::FindType)
  поиск ведется через parent_element обобщения, а не переменной
- Корректная генерация кода при подстановке специализированной обобщенной
  переменной в качестве фактического параметра вместо формального параметра
  специализирующего типа
- Генерация кода выбора обработчика в обобщенной процедуре в случае наличия помимо
  обобщенных обычных формальных параметров
- Корректная обработка подстановки символьной константы в качестве фактического
  параметра вместо формального параметра - открытого массива


O2M v1.7.148 - 2004.02.03
* Убран метод CCommonPars::ScalarTypePresent, теперь проверка наличия обработчика
  парам. спец-ции производится в CCommonFPSection::AssignFPElems
- В CQualidentType::CreateVar используется GetModuleAlias вместо GetModuleName
- В CCommonVar::WriteCPP_fp и CCommonType::WriteCPP учитывается вариант, когда
  вместо настоящего названия модуля используется псевдоним
- Проверка наличия в обобщенных параметрах процедуры только обобщенных типов
- Проверка правильного использования VAR в обобщенных параметрах
- Исправление C++ кода типа ук. на обобщение в соответствии с ANSI C++


O2M v1.7.149 - 2004.02.09
! Изменен формат .2ml файлов в соответствии с Link2M v005
* Версия отображается в форме 1.7.149, убрано "beta"
* Небольшая оптимизация обработки командной строки
* CGuard перестал быть наследником CBase, другие мелкие изменения в названиях
  и структурах объектов
+ Проверка обязательного наличия в процедуре-функции оператора RETURN
+ Выдача предупреждения, если не все последовательностити операторов в
  процедуре-функции содержат оператор RETURN
- В CCopyStdProc::Init не проверялось наличие ошибок при разборе выражений


O2M v1.7.150 - 2004.06.01
* Функции GetGlobalName из глобальной области перенесены внутрь класса CBaseName
- В CQualidentType::CreateVar убран вызов GetModuleAlias (приводит к ошибке при
  использовании типа ук., импортированного из модуля, который его в свою очередь
  импортирует)
- В CLexBuf::ReadLex при обработке конца файла сбрасывается текущая позиция,
  иначе при обнаружении ошибки в конце файла выдается позиция предыдущей лексемы
- Проверяется наличие имени модуля (названия типа) при использовании уточненного
  названия типа (уточненного идентификатора), исправлено позиционирование при
  обнаружении ошибки в первом идентификаторе уточненного идентификатора
- CCommonType::CheckSpecType - при получении типа специализации используется
  переданный извне parent_element для обработки специализаций из других модулей
- В CCommonVar::FindType поиск типа специализации ведется в области видимости
  текущего модуля, а не в области видимости обобщенного типа - теперь корректно
  ищется содержимое специализации импортированного типа
- Уточнены сообщения об ошибках в конце модуля и всех видов процедур - вначале
  проверяется наличие идентификатора, потом его соответствие названию модуля
  (процедуры)


O2M v1.8.151 - 2004.06.21
! Повышение номера версии до 1.8
! Для корректной компиляции проектов необходимо использование Link2M v1.8.7 и
  выше, Pro2M v1.8.34 и выше
! Изменена работа с O2M makefile - теперь он используется для хранения списка
  файлов, требующих компиляции c++, данный файл считывается и перезаписывается
  при каждом запуске O2M
* В проект добавлена библиотека для работы с XML (из проекта Link2M), для
  хранения списка файлов, входящих в проект, вместо специализированного списка
  используется XML контейнер
* Из проекта исключены файлы "make.cpp" и "make.h", константы с текстом
  комментариев для .cpp/.2mk кода перенесены из "Base.h" в "Common.h", запись
  .2mk файла перенесена из make_O2M_makefile(...) в CProject::Write2mk
+ Добавлен ключ -d для сброса содержимого O2M makefile (необходимо при
  компиляции первого файла в проекте)
+ Реализована работа WITH с параметрами-переменными и указателями обобщенных
  типов
+ Доп. проверки наличия ошибок доступа к файлам при генерации кода
- В CCommonVar::FindType при получении названия модуля, содержащего тип
  специализации, при необходимости используется имя модуля из обобщенного типа
  (необходимо для явного признака, объявленного в импортированном модуле)


O2M v1.8.152 - 2004.06.25
* В операторе WITH для обобщенных переменных и указателей на обобщения после
  ":" указывается только "<" признак ">" без имени типа
* Оптимизация CProject::Write2mk - работа без выделения памяти под строки
+ В WITH проверяется использование пустого указателя, в этом случае срабатывает
  секция по умолчанию (или прерывание программы)
+ Доп. проверки отсутствия ошибок при закрытии файлов
- В CGuard::CreateGuardVar() в случае обобщенной переменной в переменной
  сохраняется описание признака для определения действительного типа
  параметризованной переменной внутри охраняемой послед-ти операторов
- В CCommonType::SSpec добавлен признак IsExtended, означающий, что данная
  специализация добавлена путем расширения обобщения (+=), это необходимо для
  поиска типа специализации в CCommonVar::FindType() (при отсутствии уточнения
  перед именем типа не требует добавления алиаса модуля из обобщения)
- В обработчике парам. спец-ции, объявленном в виде WrongName.ProcName, при
  неверном указании имени модуля исправлено позиционирование на место ошибки
- В CProject::AddFullPathMakeFile при выделении пути учитывается конечный слэш


O2M v1.8.153 - 2004.08.03
+ IS работает с обобщениями - используется синтаксис вида IS "<" признак ">",
  изменен способ разбора IS (в т.ч. в случае обычных указателей)
+ Реализована возможность присвоения содержимого записей через указатели
  на параметризованные переменные
+ Разрешены указатели на специализации (параметризованные обобщенные типы)
+ Разрешены объявления именованных параметризованных обобщенных типов
  (типов-специализаций)
- В IS проверяется, является ли указанный тип расширением типа проверяемой
  переменной
- В лексическом анализаторе начала идентификаторов, совпадающие с ключевыми
  словами, интерпретировались как отдельные лексемы


O2M v1.8.154 - 2004.08.11
* При записи объявления типа через WriteDFN (в наследниках CBaseType),
  записывается только объявление типа без имени. При необходимости записи
  объявления типа через ук. на CBaseType используется полиморфный вызов
  WriteDFN вместо использования "switch"
+ Проверка отсутствия экспорта расширения обобщения
- В CCommonType::WriteDFN убран код генерации расширения обобщения (расширение
  не может экспортироваться => его не требуется записывать в DFN файл)
- Убран CCommonType::Qualident - случайно сохранился еще от CRecordType
- Убраны CheckComplete из CCommonType и CSpecType (содержат только именованные
  типы, для которых проверка завершенности выполняется при объявлении типа)
- Возможность обращения к полям записи через указатель на специализацию


O2M v1.8.155 - 2004.08.25
! Изменен формат .2ml файлов, для корректной обработки проектов необходимо
  использование Link2M v1.8.8 и выше
* В .2ml файл записывается признак наличия обработчика по умолчанию у обобщенной
  процедуры, обозначение обобщенной процедуры изменено на <CProc ... />
* В .2ml файле <Spec Default="yes" ... /> сокращено до <Spec Def="yes" ... />
! Вместо использования поля O2M_SYS_ID используется виртуальный метод с
  аналогичным названием, возвращающий ук. на строку ид. типа времени исполнения;
  для корректной компиляции c++ необходимо использовать Link2M v1.8.8 и выше,
  библиотеку Import v1.8.8 и выше
- При разборе обработчика параметрической специализации проверяется наличие
  обобщенной процедуры, к которой должен быть привязан обработчик


O2M v1.8.156 - 2004.08.29
! Изменения в реализации механизма PPP, требуется Link2M v1.8.10 и выше
* В коде с++ вместо O2M_INIT_FUNC_... при параметризации обобщения используется
  O2M_INIT_... (требуется Link2M v1.8.10 и выше)
* В коде с++ вместо O2M_FREE_FUNC... (указатель на процедуру очистки памяти)
  используется O2M_SID... (идентификатор специализации), т.к. использование ук.
  на процедуру вызывало проблемы в MSVC++6.0 - в результате оптимизации все
  адреса процедур оказывались одинаковыми (требуется Link2M v1.8.10 и выше)
* Использование XML парсера v1.0.003 из Link2M, где необходимо, в концах файлов
  добавлены переводы строк - для подавления warning под MinGW v3.1.0
* Во всех генерируемых компилятором файлах в конце файла ставится перевод
  строки (для подавления warning MinGW v3.1.0)
* Оптимизирован класс CPP_files (убраны неиспользуемые поля, открытие файлов
  перенесено из конструктора в метод Init, не используется error_FileOpen),
  проверка наличия каталога "/CPP" теперь выполняется в CPP_files::Init
* Создание файлов "_O2M_sys.cpp" и "_O2M_sys.h" осуществляется только при
  обработке главного файла проекта
* Изменения в main(): доп. проверки при работе с файлами, сообщения об ошибках
- Оптимизация класса DFN_file, устранение утечки памяти
- Везде при использовании "friend" добавлено "class" - требование стандарта
  языка с++, не требуется в MSVC++6.0 и MinGW v2.95, требуется в MinGW v3.1.0
- В CLexBuf::ReadLex убрана проверка if (!CurrLex), в конструкторе CLexBuf
  убрана инициализация CurrLex(NULL) - CurrLex не является указателем


O2M v1.8.157 - 2004.09.02
* Поле CRecordVar::FieldStore изменено для хранения эл-тов типа CBaseVar*
- При генерации С++ кода WITH и IS исправлен пропуск имени модуля в случае
  признака - типа, объявленного в одном модуле с WITH (IS)
- В CRecordVar::WriteCPP для переменных неименованного типа убран O2M_SYS_ID,
  исправлена генерация кода экспортируемых переменных неименованного типа запись
- Исправлен вылет при разборе IS в случае переменной неименованного типа
- В CIdentList::AssignVars проверяется попытка объявления неспециализированной
  обобщенной переменной


O2M v1.8.158 - 2004.09.08
+ Проверка совпадения количеств формальных параметров в опережающем описании и
  объявлении процедуры
+ Поддержка работы со специализациями по умолчанию
+ Проверка объявления непараметризованного обобщения в параметрах процедуры,
  VAR параметр непараметризованного обобщенного типа интерпретируется как
  указатель на непараметризованное обобщение
- В CDeclSeq::ProcInit проверяется ошибка "повторное объявление имени" для
  процедуры не связанной с типом, убрано неверное преобразование типов
- Именованный параметризованный обобщенный тип может использоваться в обобщающих
  параметрах обработчиков параметрических специализаций
- Проверка объявления неименованного обобщенного типа в параметрах процедуры


O2M v1.8.159 - 2004.11.01
* В обобщенной процедуре без обработчика по умолчанию не производится
  инициализация/деинициализация массивов
* Убрана лишняя генерация меток O2M_RETURN в коде процедур и тела модуля
* Оптимизирована генерация инициализации/деинициализации массивов в процедурах
- При генерации кода вызова обработчика в обобщенной процедуре проверяется
  наличие параметра-массива и, при необходимости, генерируется подстановка
  параметров, содержащих размерности массива


O2M v1.8.160 - 2004.11.05
* Подправлена CExprList::WriteCPP_proc_OneParam, теперь в случае многомерных
  символьных массивов корректно генерируется код параметров при вызове
  процедур (функций)
+ Реализована возможность присвоения массиву символов строки символов
- Исправлена генерация кода ст. процедуры COPY, теперь в качестве источника
  текста можно использовать переменную
- При объявлении ук. на массив генерируются доп. переменные, содержащие
  размерности массива, при использовании NEW в данные переменные заносятся
  действительные значения размерностей. Теперь можно использовать открытые
  массивы в блоке BEGIN..END модуля
- Исправлена генерация кода ф-ции NEW в случае многомерных массивов


O2M v1.8.161 - 2004.12.10
- Убран вылет в случае использования специализации типа NIL, для корректной
  обработки таких специализаций необходимо применять Link2M v1.8.12 или выше
- В CCommonVar::WriteCPP для записи имени признака используется CPPCompoundName
- В CCommonVar::SetTagName изменен способ генерации CPPCompoundName для
  устранения ошибки - неверной генерации имени признака в случае записи кода
  переменной специализированного типа, параметризованного импортированным типом


O2M v1.8.162 - 2005.05.12
- Убран вылет в CCommonType::FindSpecByName при сравнении пустого alias_name
  со строкой
- Исправлена генерация кода в случае, когда объявляется ук. на еще не объявленный
  тип массив
